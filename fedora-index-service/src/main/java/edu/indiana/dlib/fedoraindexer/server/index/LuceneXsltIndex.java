/**
 * Copyright 2015 Trustees of Indiana University. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE TRUSTEES OF INDIANA UNIVERSITY ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE TRUSTEES OF INDIANA UNIVERSITY OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of the Trustees of Indiana University.
 */
package edu.indiana.dlib.fedoraindexer.server.index;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.StringReader;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.rmi.RemoteException;
import java.util.Properties;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.lucene.document.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import edu.indiana.dlib.fedora.client.FedoraException;
import edu.indiana.dlib.fedora.client.iudl.DLPFedoraClient;
import edu.indiana.dlib.fedoraindexer.server.FedoraObjectAdministrativeMetadata;
import edu.indiana.dlib.fedoraindexer.server.IndexInitializationException;
import edu.indiana.dlib.fedoraindexer.server.index.converters.GSearchStyleLuceneDocumentConverter;

/**
 * <p>
 *   An extension of {@code DefaultLuceneIndex} that represents 
 *   an index whose content is generated by using an external XSLT
 *   to transform the foxml for a given fedora object into an XML
 *   representation of the search index document.
 * </p>
 * <p>
 *   The following properties are expected for this subclass:
 *   <ul>
 *     <li>
 *       foxmlToLuceneXSLT - a required value indicating the
 *       path to an XSLT file that can be used to generate
 *       an XML file compatible with the specified converter
 *       from the foxml for the object to be indexed. 
 *     </li>
 *     <li>
 *       converter - A required value indicating the complete
 *       class name of a LuceneDocumentConverter implementing
 *       class that will be used to interpret the XML result
 *       of the transformation.
 *     </li>
 *   </ul>
 * </p>
 */
public class LuceneXsltIndex extends AtomicObjectLuceneIndex {

    private XMLReader xmlReader;

    private Transformer foxmlToLuceneTransformer;
    
    private DocumentBuilder documentBuilder;
    
    private DLPFedoraClient fc;
    
    private LuceneDocumentConverter converter;
    
    public LuceneXsltIndex(Properties config, DLPFedoraClient fc) throws IndexInitializationException {
        super(config);
        this.fc = fc;
        
        // set up the XML reader
        try {
            this.xmlReader = XMLReaderFactory.createXMLReader("org.apache.xerces.parsers.SAXParser");
        } catch (SAXException ex) {
            throw new IndexInitializationException("Unable to set up XML Reader!", ex);
        }
        
        // set up the document builder
        try {
            this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException e1) {
            throw new IndexInitializationException("Unable to initialize a DocumentBuilder!");
        }
        
        // set up the transformer
        String xsltFilename = config.getProperty("foxmlToLuceneXSLT");
        if (xsltFilename == null) {
            throw new IndexInitializationException("Required property 'foxmlToLuceneXSLT' is not set!");
        }
        // NOTE: There's a signification memory leak in the Transformer
        // generated by one of the most common default TransformerFactory
        // implementations.  The following line, and the inclusion of xalan
        // in the classpath is sufficient to sidestep that problem.
        TransformerFactory factory = new org.apache.xalan.xsltc.trax.TransformerFactoryImpl();
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(xsltFilename);
            Source xslt = new StreamSource(fis);
            Templates templates = factory.newTemplates(xslt);
            this.foxmlToLuceneTransformer = templates.newTransformer();
        } catch (FileNotFoundException ex) {
            throw new IndexInitializationException("XSLT file not found! (\"" + new File(xsltFilename).getAbsolutePath() + "\")", ex);
        } catch (TransformerConfigurationException ex) {
            throw new IndexInitializationException("Error generating Transformation! (\"" + new File(xsltFilename).getAbsolutePath() + "\")", ex);
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException ex) {
                    throw new IndexInitializationException("Unable to close file: \"" + new File(xsltFilename).getAbsolutePath() + "\"", ex);
                }
            }
        }
        
        // set up the converter
        String converterClassName = config.getProperty("converter");
        if (converterClassName == null) {
            LOGGER.info(this.getIndexName() + ": No converter specified, using GSearch Style converter.");
            this.converter = new GSearchStyleLuceneDocumentConverter();
        } else {
            try {
                Class converterClass = Class.forName(converterClassName);
                this.converter = (LuceneDocumentConverter) converterClass.newInstance();
            } catch (ClassNotFoundException ex) {
                throw new IndexInitializationException("Unknown converter class: " + converterClassName, ex);
            } catch (InstantiationException ex) {
                throw new IndexInitializationException("Error instantiating converter class: " + converterClassName, ex);
            } catch (IllegalAccessException ex) {
                throw new IndexInitializationException("Illegal access on converter class: " + converterClassName, ex);
            }
        }
    }
    
    /**
     * Creates an index {@code Document} object for the fedora object
     * indicated by the provided object administrative data.  This
     * implementation, using an existing APIM interface to request 
     * the full foxml representation of the object, performs a
     * transformation based on the configured XSLT.  The resulting 
     * XML (which may not be valid) represents a serialized version
     * of a lucene {@code Document} which is used in the generation
     * of the {@code Document} returned by this method.
     */
    protected Document createIndexDocument(FedoraObjectAdministrativeMetadata adminData) throws RemoteException, IOException, TransformerException, ParserConfigurationException, SAXException, FedoraException {
        LOGGER.debug("Entered " + this.getClass().getName() + ".createIndexDocument()");
        org.w3c.dom.Document foxmlDoc = null;
        StringReader foxmlReader = null;
        ByteArrayOutputStream luceneOS = new ByteArrayOutputStream();
        StringReader luceneReader = null; 
        try {
            // get the foxml file
            foxmlDoc = fc.exportObjectAsDocument(adminData.getPid());
            
            // transform the foxml file
            DOMSource source = new DOMSource(foxmlDoc);
            StreamResult luceneStreamResult = new StreamResult(luceneOS);
            this.foxmlToLuceneTransformer.transform(source, luceneStreamResult);
            luceneOS.close();
            try {
                org.w3c.dom.Document dom = this.documentBuilder.parse(new InputSource(new StringReader(luceneOS.toString("UTF-8"))));
                return this.converter.convert(dom);
            } catch (SAXException ex) {
                LOGGER.error("Error reading lucene doc: " + luceneOS.toString("UTF-8"), ex);
                throw ex;
            } catch (IOException ex) {
                LOGGER.error("Error reading lucene doc: " + luceneOS.toString("UTF-8"), ex);
                throw ex;
            }
        } finally {
            if (foxmlReader != null) {
                foxmlReader.close();
            }
            if (luceneOS != null) {
                luceneOS.close();
            }
            if (luceneReader != null) {
                luceneReader.close();
            }
        }
    }
    


}
