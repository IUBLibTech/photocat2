/**
 * Copyright 2011, Trustees of Indiana University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *   
 *   Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *   
 *   Neither the name of Indiana University nor the names of its
 *   contributors may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *   
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. 
 */
package edu.indiana.dlib.catalog.config.impl;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.util.Properties;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/**
 * <p>
 *   An EntityResolver implementation that maintains a disk cache
 *   of the Schema files.
 * </p> 
 */
public class SchemaCachingEntityResolver implements EntityResolver {

    /**
     * The file system directory in which cached schema files
     * are managed.
     */
    private File cacheDirectory;
    
    /**
     * A mapping from schema locations to cached schema files
     * this is also serialized to disk in the cache directory.
     */
    private Properties mapping;

    /**
     * For statistical purposes, this is the number of cache
     * hits for this EntityResolver instance.
     */
    private int cacheHits;
    
    /**
     * For statistical purposes, this is the number of cache
     * misses for this EntityResolver instance.
     */
    private int cacheMisses;
    
    /**
     * Creates a SchemaCachingEntityResolver with the given cache directory.
     * Files present in the cache directory will be used, and may be over-
     * written by this class.
     */
    public SchemaCachingEntityResolver(File cacheDirectory) throws IOException {
        this.cacheDirectory = cacheDirectory;
        this.cacheHits = 0;
        this.cacheMisses = 0;
        cacheDirectory.mkdirs();
        this.mapping = new Properties();
        File mappingFile = new File(this.cacheDirectory, "schema-map.properties");
        if (mappingFile.exists()) {
            FileInputStream fis = new FileInputStream(mappingFile);
            try {
                this.mapping.load(fis);
            } finally {
                fis.close();
            }
        }
    }
    
    public synchronized void clearCache() throws IOException {
        for (Object key : this.mapping.keySet()) {
            File file = new File((String) this.mapping.get(key));
            file.delete();
        }
        this.mapping.clear();
        this.storeMappingFile();
    }
    
    private void storeMappingFile() throws IOException {
        // store the cache mapping file
        File mappingFile = new File(this.cacheDirectory, "schema-map.properties");
        FileOutputStream fos = new FileOutputStream(mappingFile);
        try {
            this.mapping.store(fos, "Automatically generated by the SchemaCachingEntityResolver.");
        } finally {
            fos.close();
        }
    }

    /**
     * Checks the cache, and if missing, fetches the remove file and caches
     * it, then returns a new InputSource to access the cached file.
     */
    public synchronized InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
        if (systemId != null) {
            // check the cache
            if (this.mapping.containsKey(systemId)) {
                this.cacheHits ++;
            } else {
                this.cacheMisses ++;
                
                // fetch and store the file
                URL url = new URL(systemId);
                File file = new File(cacheDirectory, generateUrlFilenameHash(systemId));
                if (file.exists()) {
                    throw new IllegalStateException("Name collision! (" + file.getName() + ")");
                }
                writeStreamToFile(url.openStream(), file);
                this.mapping.put(systemId, file.getAbsolutePath());
                
                this.storeMappingFile();
            }
        }
        InputSource is = new InputSource(systemId);
        is.setByteStream(new FileInputStream(this.mapping.getProperty(systemId)));
        return is;
    }
    
    /**
     * A private helper method to generate a hash of a URL that 
     * is suitable for a filename.  The current implementation
     * removes "http://" from the String and replaces all other
     * "/" characters with hyphens.
     */
    private String generateUrlFilenameHash(String urlString) {
        return urlString.replace("http://", "").replace("/", "-");
    }

    /**
     * A helper method to use NIO functions to efficiently write
     * an InputStream to a file.
     */
    private static void writeStreamToFile(InputStream is, File file) throws IOException {
        OutputStream output = new FileOutputStream(file);
        ReadableByteChannel inputChannel = Channels.newChannel(is);  
        WritableByteChannel outputChannel = Channels.newChannel(output);  
        ByteBuffer buffer = ByteBuffer.allocateDirect(16 * 1024);  
        while (inputChannel.read(buffer) != -1) {  
            buffer.flip();  
            outputChannel.write(buffer);  
            buffer.compact();  
        }  
        buffer.flip();  
        while (buffer.hasRemaining()) {  
            outputChannel.write(buffer);  
        }  
       inputChannel.close();  
       outputChannel.close();
    }    
}
